#序列比较(2)



## 子序列与完整序列的比对

有时我们希望知道一个较长序列是否含有与某个较短序列相似的子序列（例如寻找某个DNA序列中是否出现某种基因特征），并且允许个别地方的不同。可以使用动态规划方法。

局部的比对（local alignment）算法。使用打分函数表示两个序列相似程度。例如可以设定字符匹配得分为+1，失配得分为0，空位罚分为-1（可使用不同的设定）。

**问题**：给定序列s、t，寻找序列t的子序列，使得该子序列与t相似度最大。设t[0~i]中子序列与s[0~j]的最大相似度为S(i, j)。

局部比对意味着不计删除序列t前缀的得分，因而初始化的过程为：

	for i = 0 -> len(t):
		S(i, 0) = 0

同时局部比对也不计删除序列t后缀的得分，因此：

	S(i, j) = max{
		S(i-1, j-1) + diff(i, j)
		S(i, j-1) + insert(j)
		S(i-1, j)
	}

##寻找最大的相似子序列

有时我们希望找到两条序列的功能相关的子序列，例如黑猩猩和人类DNA的相似子序列。这种情况下，需要设计序列局部相似性的比较算法。

设序列s和t的长度分别为m,n。设得分函数只奖励匹配，即匹配奖励分值为+1，失配罚分为-1，空位罚分为-1。

由于两个被比较序列的前缀的得分都不被计入，因此初始化为：

	S(i, 0) = 0  (0<=i<=m)
	S(0, j) = 0  (0<=j<=n)

由于在每个比较位置总有一个得分为0的空后缀比对，因此矩阵中所有得分都大于或等于0。递归公式为：

	S(i, j) = max{
		S(i-1, j-1) + diff(i, j)
		S(i, j-1) + insert(j)
		S(i-1, j) + insert(i)
		0
	}

阈值“0”意味着矩阵中的“0”元素分布区域对应于不相似的子序列，而正数区域则是局部相似的区域。最后，在矩阵中找最大值，该值就是最优的局部比对得分，它所对应的点为序列局部比对的末点.

###ref:

http://www.lmbe.seu.edu.cn/chenyuan/xsun/bioinfomatics/Web/CharpterThree/3.2.html

