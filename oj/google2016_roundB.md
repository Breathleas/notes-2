#Google APAC test 2016-round B 总结

Round B错过时间了没参加上，做了下练习感觉挺难的。

##Problem A Travel

N个城市（标号从1到N）由M条路（无向边）相连。每条道路在不同时刻出发所用的时间有区别（和方向无关）。所有出发时间（在每个城市）都是整数（0时~23时），假设到达一个城市后可以立即出发到下一个城市。 Chelsea计划在时刻S从城市1出发目标为城市D，求最短所用时间（也可能无法到达）。

每组输入：城市数目N，道路数M，每条道路的两个端点、以及24个数字依次表示每个整点出发所用时间。并且Cost[t] ≤ Cost[t+1]+1 (0 ≤ t ≤ 22) 、 Cost[23] ≤ Cost[0]+1。每组对应K个问题，每个问题对应一个目的D和出发时刻S。（注意两个城市间可能不止一条路）

**分析：**

由于每个出发时刻的花费小于下一时刻的花费+1，因而对于最优解一定是到达某一城市就立刻出发。

可看作为变形版本的单源最短路径问题，使用动态规划来解决。

先看普通的单源最短路径问题的Dijkstra算法：集合U，V在开始时刻U中只有源点，V中包含其他点。不变式为U中的点到源点的最短路径是已知的。每次寻找V中到源点最近（更新后的距离）的点加入U，直到V为空。时间复杂度O(n^2)。

由于问题中路径长度与时间有关，相当于所有点增加一个维度。我的方式是每次计算新加入U的点时对所有时刻均计算一次，即每次相当于加入24个点。并且最小花费数组为Min[n, t]: 表示在原点从时刻t出发到达点n所用时间。

需要注意的地方是，由于在中间点的出发时间等于到达该点的最小时间，因而需要额外的一层搜索。具体而言，对于时间t，要计算下一个加入U的点q，则q满足：对于所有在集合U中的点p，`Min[p, t]+Dist[p, q, (t+Min[p, t])%24]`最小。其中由于t为从源点的出发时间，于是`(t+Min[p, t])%24`为从p出发到q的出发时间。因此每次加入新点的时间消耗为O(n^2)（寻找q和遍历p）。总算法时间为O(n^3)，而对每个问题则可以立即查询Min[D, S]得到结果。

<font color="#FF0000">**存在问题：**</font>主要在搜索时犯了错误，没注意行走的方向是从源点出发，把`Min[p, t]+Dist[p, q, (t+Min[p, t])%24]`这个式子搞错了，多花了一些时间。而且对Dijkstra算法不熟。并且城市下标和数据里的对应应注意。而且如何进行动态规划想了半天。

##Problem B gWheels

山地车通常有两组齿轮，每个齿轮可有不同数目的齿，链条链接两组齿轮，则两个被选中的齿轮齿数有个比例（决定了转速比）。有个特殊山地车有三组齿轮，前后两组齿轮p和t分别有一个齿轮连在中间齿轮组e上（不能连在同一个e中的齿轮上）。问给定p、e和t中每个齿轮数量，能否产生比例P\Q?其中PQ为两整数，并且可能不是互质的。

**分析：**

（想一下应该是每组齿轮都是同心的样子。）然后其实就是找i、j、k、h使`p[i]*e[j]*Q = t[k]*e[h]*P`并且`j!=h`。最蠢的可以暴力来做。我想到好一点的办法是把e排序，这样对h搜索时可以根据要匹配的结果进行二分查找，时间变为O(n^3\*lg(n))。然而只能过小用例，过不了大用例。

参考了做出来的选手的代码，发现是提前计算了所有的`p[i]*e[j]`和`t[k]*e[h]`，然后搜索时对其中一个进行二分查找。因而空间复杂度为O(n^2)， 时间复杂度为O(n^2\*lg(n))。

<font color="#FF0000">**存在问题：**</font>主要是没想到空间换时间。其他的小问题：存放中间结果的变量类型设成int结果导致overflow；快排不熟练写了半天；由于`t[k]*e[h]`或`p[i]*e[j]`在比较时已经是经过排序的因此需要额外数据保存j和h原来的下标值。

<font color="#FF0000">总之要注意数据类型和overflow问题。</font>

##Problem C gNumbers

一个正整数称为gNumbers，当：该数各位相加的和只能被1和它自己整除。（1也是gNumbers。）

游戏：两玩家回合制，设起始数字为N：若某玩家的回合N为gNumbers则该玩家输；否则该玩家可以选取N的一个质数因数C除N，直到N不能被C整除，除得的数作为新的N开始另一玩家的回合。

Laurence and Seymour，每局都由Laurence开始，假设每个玩家的选择都是最有利于自己的，给定起始数N，求赢家是谁。

**分析：**

这类问题都是可以递归的做，总之就是WinState和LoseState相互怎么进入的问题。如果做了某选择后是LoseState那么当前就是WinState；如果进入不了WinState（或者已经输了）那么当前就是LoseState。（两个状态是互斥并且互补的。）如果条件允许还可以使用**动态规划**，因为会有重复子问题。

<font color="#FF0000">**存在问题：**</font>一开始isWin()函数和isLose()函数作用没想清（其实只要isLose()就够了）。后面对都应当除以那些因子、以及除完剩下的是啥没搞清楚，以至于一直错。并且应当注意如果N不是gNumber并且N为质数，那么就赢了（拿走N剩下1）。总之因为没想清楚，挨个检查测试例才发现错误。（因此选择问题的时候最好选测试例方便手算的，有错误至少能找啊= =）

最后的解法：isLose()递归调用自己。如果N是gNum则输了，否则先对N做质数分解然后依次对每个因子做递归尝试（注意没有因子就是N是质数就赢了！），如果没有产生LoseState那么当前就是LoseState输了。

我还很机智地在程序一开始把sqrt(Max_N)以下所有质数都算出来了，在判断gNumber和质数分解时都可以用，所以大测试例的时间很容易满足。然并卵，脑子不清楚依旧花了不少时间。。

##Problem D. Albocede DNA

外星DNA的一段由abcd组成：

- It contains at least one copy of each of a, b, c, and d.
- All as come before all bs, which come before all cs, which come before all ds.
- There are exactly as many 'a's as 'c's.
- There are exactly as many 'b's as 'd's.

外星DNA Albocede-n由n段上述DNA片段组成，如abcd 和 aaabcccdaabbbccdddabcd。

给定一个串，求其不同的满足Albocede-n pattern的subsequence数量。

**分析：**

注意subsequence定义是某个串去掉若干个(可以是0)元素（但其余元素顺序不变）产生的新串。

想了半天也没想出来，研究下了做出来的选手的代码，是用的动态规划。数组`dp[N][N/2][N/2][4]`最后的下标表示累加状态、第一个下标表示统计到的输入串s的位置下标，中间两个表示a与c和b与d的数目之差应该是；对每个输入串是对每个i、j、k搜索`dp[i][j][k]`，对s[i]分情况讨论。

总之也没太看懂，看了个大概，反正做不出来放弃了。

##总结

这轮好难，真参加的最多只能做出来个A或者C吧。。

</br></br></br></br>